<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>line chart</title>

    <style> /* set the CSS */

    /* Style the lines by removing the fill and applying a stroke */
    .line {
        fill: none;
        stroke: #ffab00;
        stroke-width: 3;
    }

    </style>
</head>
<body>
<p>Test Here:</p>
<div id="test"></div>

<!-- load the d3.js library -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

    function drawLineChart(date, cityname){
        // parse the date / time
        var parseTime = d3.timeParse("%H");

        // Get the data
        var airQuality = [];

        // Read in all records of an assigned date
        for (let hour=1; hour <24; hour+=2 ){
            let H = hour.toString();
            let D = date.toString();
            if(H.length < 2){
                H = "0" + H;
            }
            if(D.length < 2){
                D = "0" + D;
            }

            // define the file name
            // Change the path when necessary
            // Attention: use "\\" instead of "\"
            let jsonfilename = "data\\APIdata"+ D + H + ".geojson";
            let xhr = new XMLHttpRequest();
            xhr.open('GET', jsonfilename, false);
            xhr.send();
            let geojsonData = JSON.parse(xhr.responseText);
            //d3.json(jsonfilename, function(error, geojsonData) {
            //if (error) throw error;
            //})
            geojsonData["features"].forEach(function(row){
                if (row["properties"]["city"] === cityname) {
                    row["properties"]["hour"] = hour;
                    airQuality.push(row["properties"]);
                }
            });
        }


        var fields = ["aqi", "pm10", "pm25", "no2", "co", "so2", "o3"];

        // Check the time of data
        if (airQuality[0]["time"] === airQuality[1]["time"]){
            var errorMassage = "The historical data of this city is not available.";
            return errorMassage;
        }

        // format the data
        airQuality.forEach(function(element){
            element["hour"] = parseTime(element["hour"]);
            element["aqi"] = +element["aqi"];
            element["pm10"] = +element["pm10"];
            element["pm25"] = +element["pm25"];
            element["no2"] = +element["no2"];
            element["co"] = +element["co"];
            element["so2"] = +element["so2"];
            element["o3"] = +element["o3"];
        });

        // Sort the data according to GMT(BST)
        airQuality.sort(function(a, b){
            return a["hour"]-b["hour"];
        })

        // Creat chart for every contaminant
        for (let i=0; i<fields.length; i++){
            let contaminant = fields[i];
            if (typeof airQuality[0][contaminant] == 'undefined'){

            }
            else if (airQuality[0][contaminant] < 0
                && airQuality[1][contaminant] < 0
                && airQuality[0][contaminant] === airQuality[1][contaminant] ){
            }

            else{
                // set the dimensions and margins of the graph
                var margin = {top: 5, right: 5, bottom: 50, left: 40},
                    width = 300 - margin.left - margin.right,
                    height = 130 - margin.top - margin.bottom;

                // set the ranges
                var x = d3.scaleTime().range([0, width]);
                var y = d3.scaleLinear().range([height, 0]);

                // define the line
                var valueline = d3.line()
                    .x(function(d) { return x(d.hour); })
                    .y(function(d) { return y(d[contaminant]); });

                // append the svg object to the body of the page
                // appends a 'group' element to 'svg'
                // moves the 'group' element to the top left margin
                var svg = d3.select("body").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");


                // Scale the range of the data
                x.domain(d3.extent(airQuality, function(element) { return element["hour"]; }));
                y.domain([0, d3.max(airQuality, function(element) { return element[contaminant]; })]);

                // Add the valueline path.
                svg.append("path")
                    .data([airQuality])
                    .attr("class", "line")
                    .attr("d", valueline);

                // Add the X Axis
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));

                // Add the Y Axis
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Add tags to axis
                //svg.append("text")
                    //.attr("transform",
                        //"translate(" + (width/2) + " ," +
                        //(height + margin.top + 20) + ")")
                    //.style("text-anchor", "middle")
                    //.text("Time");

                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - margin.left)
                    .attr("x",0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text(contaminant);
            }

        }
        return svg;

    }



    // Trigger the function
    var date = 14;
    var cityname = "Shanghai";
    //drawLineChart(date, cityname)




    // a new one

    function drawLineChart_2(date, uniqId, divID){
        // parse the date / time
        var parseTime = d3.timeParse("%H:%M:%S");
        var formatTime = d3.timeFormat("%H:%M");

        // Get the data
        var airQuality = [];

        // Read in all records of an assigned date
        for (var i=0; i <11; i++ ){
            let H = i.toString();
            let D = date.toString();
            if(H.length < 2){
                H = "0" + H;
            }
            if(D.length < 2){
                D = "0" + D;
            }

            // define the file name
            // Change the path when necessary
            // Attention: use "\\" instead of "\"
            let jsonfilename = "../data/stationData/STATIONdata"+ D + H + "_merged.geojson";
            let xhr = new XMLHttpRequest();
            xhr.open('GET', jsonfilename, false);
            xhr.send();
            let geojsonData = JSON.parse(xhr.responseText);
            //d3.json(jsonfilename, function(error, geojsonData) {
            //if (error) throw error;
            //})
            geojsonData["features"].forEach(function(row){
                if (row["properties"]["id"] === uniqId) {
                    let strList = row["properties"]["time"].split("T");
                    row["properties"]["hour"] = strList[1];
                    row["properties"]["order"] = i;
                    airQuality.push(row["properties"]);
                }
            });
        };


        // a error report
        var errorMassage = "The historical data of this city is not available.";
        if (airQuality.length === 0){
            return errorMassage;
        }


        var fields = ["aqi", "pm10", "pm25", "no2", "co", "so2", "o3"];

        // Check the time of data
        if (airQuality[0]["time"] === airQuality[1]["time"]){
            return errorMassage;
        }

        // format the data
        airQuality.forEach(function(element){
            var T = parseTime(element["hour"]);
            element["hour"] = formatTime(T);
            element["aqi"] = +element["aqi"];
            element["pm10"] = +element["pm10"];
            element["pm25"] = +element["pm25"];
            element["no2"] = +element["no2"];
            element["co"] = +element["co"];
            element["so2"] = +element["so2"];
            element["o3"] = +element["o3"];
        });

        // Sort the data according to GMT(BST)
        airQuality.sort(function(a, b){
            return a["order"]-b["order"];
        });
        console.log(airQuality);

        // Creat chart for every contaminant
        for (let i=0; i<fields.length; i++){
            let contaminant = fields[i];
            if (airQuality[0][contaminant] < 0
                && airQuality[1][contaminant] < 0
                && airQuality[0][contaminant] === airQuality[1][contaminant] ){

            }

            else{
                // set the dimensions and margins of the graph
                var margin = {top: 5, right: 5, bottom: 50, left: 40},
                    width = 300 - margin.left - margin.right,
                    height = 130 - margin.top - margin.bottom;

                // set the ranges
                var x = d3.scaleTime().range([0, width]);
                var y = d3.scaleLinear().range([height, 0]);

                // define the line
                var valueline = d3.line()
                    .x(function(d) { return x(d.hour); })
                    .y(function(d) { return y(d[contaminant]); });

                // append the svg object to the body of the page
                // appends a 'group' element to 'svg'
                // moves the 'group' element to the top left margin
                var svg = d3.select(divID).append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");


                // Scale the range of the data
                x.domain(d3.extent(airQuality, function(element) { return element["hour"]; }));
                y.domain([0, d3.max(airQuality, function(element) { return element[contaminant]; })]);

                // Add the valueline path.
                svg.append("path")
                    .data([airQuality])
                    .attr("class", "line")
                    .attr("d", valueline);

                // Add the X Axis
                svg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));

                // Add the Y Axis
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Add tags to axis
                //svg.append("text")
                //.attr("transform",
                //"translate(" + (width/2) + " ," +
                //(height + margin.top + 20) + ")")
                //.style("text-anchor", "middle")
                //.text("Time");

                svg.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - margin.left)
                    .attr("x",0 - (height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text(contaminant);
            }

        }
        return svg;

    }


    var uniqId = 3238;
    drawLineChart_2(20, uniqId, "test")


</script>

</body>
</html>